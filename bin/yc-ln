#!/bin/bash

# Bookface <-> YCInternal Symlink Helper
# Automatically detects source directory and creates symlink in the opposite directory

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

success() {
    echo -e "${GREEN}✓ $1${NC}"
}

info() {
    echo -e "${BLUE}ℹ $1${NC}"
}

warn() {
    echo -e "${YELLOW}⚠ $1${NC}"
}


# Check requirements
if ! git rev-parse --git-dir &> /dev/null; then
    error "Not in a git repository"
fi

if ! command -v fzf &> /dev/null; then
    error "fzf is required but not installed"
fi

# Check if both directories exist
if [[ ! -d "ycinternal" ]]; then
    error "ycinternal directory does not exist in current path"
fi

if [[ ! -d "bookface" ]]; then
    error "bookface directory does not exist in current path"
fi

# Find all files in both directories using git, excluding symlinks
info "Scanning for files in ycinternal and bookface..."

YC_FILES=$(git ls-files --others --cached --exclude-standard ycinternal | while read -r file; do
    [[ ! -L "$file" ]] && echo "$file"
done)

BF_FILES=$(git ls-files --others --cached --exclude-standard bookface | while read -r file; do
    [[ ! -L "$file" ]] && echo "$file"
done)

# Combine all files
ALL_FILES=""
if [[ -n "$YC_FILES" ]]; then
    ALL_FILES="$YC_FILES"
fi
if [[ -n "$BF_FILES" ]]; then
    if [[ -n "$ALL_FILES" ]]; then
        ALL_FILES="$ALL_FILES"$'\n'"$BF_FILES"
    else
        ALL_FILES="$BF_FILES"
    fi
fi

if [[ -z "$ALL_FILES" ]]; then
    error "No files found in ycinternal or bookface directories"
fi

# Use fzf to select source file
info "Select a file to symlink to the opposite directory:"
SELECTED_FILE=$(echo "$ALL_FILES" | fzf \
    --border \
    --pointer='▶' \
    --preview 'echo "File: {}" && echo "Project: $(echo {} | cut -d/ -f1)" && echo "---" && head -20 {}' \
    --preview-window=right:50% \
    --prompt 'Source file > ' \
    --cycle \
    --no-mouse \
    --header="Files from both ycinternal and bookface - will create symlink in opposite directory")

if [[ -z "$SELECTED_FILE" ]]; then
    warn "No file selected. Exiting."
    exit 0
fi

# Determine source and target directories based on selected file
if [[ "$SELECTED_FILE" == ycinternal/* ]]; then
    SOURCE_DIR="ycinternal"
    TARGET_DIR="bookface"
    info "Selected file from ycinternal → will create symlink in bookface"
elif [[ "$SELECTED_FILE" == bookface/* ]]; then
    SOURCE_DIR="bookface"
    TARGET_DIR="ycinternal"
    info "Selected file from bookface → will create symlink in ycinternal"
else
    error "Selected file is not in ycinternal or bookface directory"
fi

# Calculate relative path within source directory
RELATIVE_PATH="${SELECTED_FILE#$SOURCE_DIR/}"
TARGET_FILE="$TARGET_DIR/$RELATIVE_PATH"
TARGET_DIR_PATH=$(dirname "$TARGET_FILE")

info "Selected: $SELECTED_FILE"
info "Target: $TARGET_FILE"

# Create target directory if it doesn't exist
if [[ ! -d "$TARGET_DIR_PATH" ]]; then
    info "Creating directory: $TARGET_DIR_PATH"
    mkdir -p "$TARGET_DIR_PATH"
fi

# Check if target file already exists
if [[ -e "$TARGET_FILE" ]]; then
    if [[ -L "$TARGET_FILE" ]]; then
        CURRENT_TARGET=$(readlink "$TARGET_FILE")
        warn "Symlink already exists: $TARGET_FILE -> $CURRENT_TARGET"
        
        echo -n "Replace existing symlink? [y/N]: "
        read -r REPLACE
        if [[ ! "$REPLACE" =~ ^[Yy]$ ]]; then
            info "Keeping existing symlink. Exiting."
            exit 0
        fi
        rm "$TARGET_FILE"
    else
        warn "File already exists (not a symlink): $TARGET_FILE"
        echo -n "Replace with symlink? [y/N]: "
        read -r REPLACE
        if [[ ! "$REPLACE" =~ ^[Yy]$ ]]; then
            info "Keeping existing file. Exiting."
            exit 0
        fi
        rm "$TARGET_FILE"
    fi
fi

# Calculate relative path from target to source using Node.js
SOURCE_ABS=$(cd "$(dirname "$SELECTED_FILE")" && pwd)/$(basename "$SELECTED_FILE")
TARGET_DIR_ABS=$(cd "$TARGET_DIR_PATH" && pwd)

RELATIVE_LINK=$(node -e "process.stdout.write(path.relative('$TARGET_DIR_ABS', '$SOURCE_ABS'))")

# Create the symlink
ln -s "$RELATIVE_LINK" "$TARGET_FILE"

# Verify the symlink works
if [[ -e "$TARGET_FILE" ]]; then
    success "Symlink created successfully!"
    info "  Source: $SELECTED_FILE"
    info "  Target: $TARGET_FILE"
    info "  Link: $RELATIVE_LINK"
    
    # Show the symlink details
    echo ""
    ls -la "$TARGET_FILE"
else
    error "Symlink creation failed or target is not accessible"
fi
